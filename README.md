# Getting Started

Spring Boot – Microservices (Integrating Spring Data Rest with HATEOAS)

In this post, we take a look how to create a microservice with the help of the Spring Boot using Spring Data REST and HATEOAS APIs. As the foundation for our microservice we would used a sample integration
https://github.com/spring-projects/spring-hateoas-examples/tree/master/spring-hateoas-and-spring-data-rest  written by the Greg Turnquist one of the authors of the Spring HATEOAS - Reference Documentation https://docs.spring.io/spring-hateoas/docs/current/reference/html/ 

If you are familiar with this project already, feel free to skip directly to the section “????? named below” where we do diverge from the approach presented by the Greg Turnquist and justify its reasoning. Otherwise, we do encourage you to keep reading the following detailed description of the project.

Complete Maven Project With Code Examples

Our Github repository has all code examples - 
https://github.com/pechersk1957/kiev-spring-rest-data-and-hateoas 

Project Dependencies

Following screenshot shows used dependencies from the Maven POM file.



Project Code Structure

Following screenshot shows the structure of the project we will create.


A few details:

 All listed classes besides the KievSpringRestDataAndHateoasApplication.java and CustomOrderHateoasController .java were written by Greg Turhquist and bearing his name as an author. 

KievSpringRestDataAndHateoasApplication.java – Spring Boot Application class generated by the Spring Boot. You have seen similar code many times before.

CustomOrderHateoasController.java – Custom controller where the integration between Spring Data REST and HATEOAS happens. 

So the last item CustomOrderHateoasController.java is the focal point of the article. But before we start to dissect it, let's repeat what are the goals for the project. The following are relevant excerpts (italic) taken from the README.adoc 
https://github.com/spring-projects/spring-hateoas-examples/blob/master/spring-hateoas-and-spring-data-rest/README.adoc I
marked by italic font intermixed with my remarks.

Defining the problem
PROBLEM: You wish to implement the concept of orders. These orders have certain status codes which dictate what transitions the system can take, e.g. an order can’t be fulfilled until it’s paid for, and a fulfilled order can’t be cancelled.
SOLUTION: You must encode a set of OrderStatus codes, and enforce them using a custom Spring Web MVC controller. This controller should have routes that appear alongside the ones provided by Spring Data REST.

Let's describe the basics of an ordering system. 
And that starts with a domain object:
@Entity
@Table(name = "ORDERS") // (1)
class Order {

    @Id @GeneratedValue
    private Long id; // (2)

    private OrderStatus orderStatus; // (3)

    private String description; // (4)

    private Order() {
        this.id = null;
        this.orderStatus = OrderStatus.BEING_CREATED;
        this.description = "";
    }

    public Order(String description) {
        this();
        this.description = description;
    }

    ...
}
The next step in defining your domain is to define OrderStatus. Assuming we want a general flow of Create an order ⇒ Pay for an order ⇒ Fulfill an order, with the option to cancel only if you have not yet paid for it, this will do nicely:
public enum OrderStatus {

  BEING_CREATED, PAID_FOR, FULFILLED, CANCELLED;

  /**
   * Verify the transition between {@link OrderStatus} is valid.
   *
   * NOTE: This is where any/all rules for state transitions should be kept and enforced.
   */
  static boolean valid(OrderStatus currentStatus, OrderStatus newStatus) {

    if (currentStatus == BEING_CREATED) {
      return newStatus == PAID_FOR || newStatus == CANCELLED;
    } else if (currentStatus == PAID_FOR) {
      return newStatus == FULFILLED;
    } else if (currentStatus == FULFILLED) {
      return false;
    } else if (currentStatus == CANCELLED) {
      return false;
    } else {
      throw new RuntimeException("Unrecognized situation.");
    }
  }
}
At the top are the actual states. At the bottom is a static validation method. This is where the rules of state transitions are defined, and where the rest of the system should look to discern whether or not a transition is valid.
The last step to get off the ground is a Spring Data repository definition:
public interface OrderRepository extends CrudRepository<Order, Long> {

}
This repository extends Spring Data Commons' CrudRepository, filling in the domain and key types (Order and Long). 

The following class preloads some testing data. I do believe that @Configuration annotation should be used instead of the @Component, but we are trying to reuse the code of our foundation as much as possible and that is the reason why we have @Component annotation in place.


@Component
public class DatabaseLoader {

  @Bean
  CommandLineRunner init(OrderRepository repository) { // (1)

    return args -> { // (2)
      repository.save(new Order("grande mocha")); // (3)
      repository.save(new Order("venti hazelnut machiatto"));
    };
  }
}

The following is how we do modify the root path of the microservice. The same thing can be also accomplished with application.properties file instead, the decision is yours.
Example 1. src/main/resources/application.yml
spring:
  data:
    rest:
      base-path: /api
It should be stated that right here, you can launch your application. Spring Boot will launch the web container, preload the data, and then bring Spring Data REST online. Spring Data REST with all of its prebuilt, hypermedia-powered routes, will respond to calls to create, replace, update and delete Order objects.
But Spring Data REST will know nothing of valid and invalid state transitions. It’s pre-built links will help you navigate from /api to the aggregate root for all orders, to individual entries, and back. But there will no concept of paying for, fulfilling, or cancelling orders. At least, not embedded in the hypermedia. The only hint end users may have are the payloads of the existing orders.
And that’s not effective.
No, it’s better to create some extra operations and then serve up their links when appropriate.
And that concludes the description of our preliminary steps. At this point you should know the goals of the project. We do know what has to be done, so let's see how it can be done. Let's talk about Spring Data REST and HATEOAS integration. Let's talk about the custom controller CustomOrderHateoasController.

CustomeOrderHateoasController

That is it! The big times! So here it is out custom controller where everything happens and all things are done!





So what does it mean?  Let's dissect at at last!
@BasePathAwareController annotation declares a controller that declares request mappings to be augmented with a base URI in the Spring Data REST configuration. In other words, our custom controller is registered under the base path /api.
The controller has a final private instance variable OrderPepository that is initialized via constructor injection.
The container has three public methods, named pay, cancel and fulfill. These three methods are the primary reason for the controller existence, namely they are responsible for order payment, cancellation and fulfillment. The implementation of these methods was transfered from the CustomOrderController.java written by Greg Turnquist.  There is nothing special about these methods and they are not related to the HATEOAS intgration. The following is code that we discussed so far. 

	private final OrderRepository repository;

	public CustomOrderHateoasController(OrderRepository repository) {
		this.repository = repository;
	}

	@PostMapping("/orders/{id}/pay")
	ResponseEntity<?> pay(@PathVariable Long id) {

		Order order = this.repository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));

		if (valid(order.getOrderStatus(), OrderStatus.PAID_FOR)) {

			order.setOrderStatus(OrderStatus.PAID_FOR);
			return ResponseEntity.ok(repository.save(order));
		}

		return ResponseEntity.badRequest()
				.body("Transitioning from " + order.getOrderStatus() + " to " + OrderStatus.PAID_FOR + " is not valid.");
	}

	@PostMapping("/orders/{id}/cancel")
	ResponseEntity<?> cancel(@PathVariable Long id) {

		Order order = this.repository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));

		if (valid(order.getOrderStatus(), OrderStatus.CANCELLED)) {

			order.setOrderStatus(OrderStatus.CANCELLED);
			return ResponseEntity.ok(repository.save(order));
		}

		return ResponseEntity.badRequest()
				.body("Transitioning from " + order.getOrderStatus() + " to " + OrderStatus.CANCELLED + " is not valid.");
	}

	@PostMapping("/orders/{id}/fulfill")
	ResponseEntity<?> fulfill(@PathVariable Long id) {

		Order order = this.repository.findById(id).orElseThrow(() -> new OrderNotFoundException(id));

		if (valid(order.getOrderStatus(), OrderStatus.FULFILLED)) {

			order.setOrderStatus(OrderStatus.FULFILLED);
			return ResponseEntity.ok(repository.save(order));
		}

		return ResponseEntity.badRequest()
				.body("Transitioning from " + order.getOrderStatus() + " to " + OrderStatus.FULFILLED + " is not valid.");
	}

Now when we know the main purpose of the controller let's discuss how the Integration with HATEOAS happens.  But first, let's stop and discuss what we are trying to accomplish.  In plain terms, our goal is to add additional links to the existing links created by Spang DataRES Api. 


And here is where HATEOAS Api comes into play. Consider the following.


Our custom controller implements this interface, and has the implementation of the method. But before we dive into its code discussion, let's stop for a minute and discuss the benfits of making controller the proccesor versus creation of the distinct processor. The foundational project chose to take the latest approach where a separate class OrgerProcessor.java https://github.com/spring-projects/spring-hateoas-examples/blob/master/spring-hateoas-and-spring-data-rest/src/main/java/org/springframework/hateoas/examples/OrderProcessor.java has been created. The major benefit of making the controller also the processor is to consolidate all related code in one place. So if you are thinking about the maintenance of your code after you are gone to the greenier pasture, we would advocate our taken approach. Otherwise every time a new developer changes/refactor the controller, he or should remember to go to the separate processor and modify it accordingly. And the tryth is that this new developr might be even unaware about its proceoor's existence in first place. By the way, if you do think about maintenance of your code in advance, you are a good person. Seriously! 

And now after we discussed why we made the controller to implement the interface of the HATEOAS, let's look inside its method implementation.

Remember, the main purpose of this method implementation is to add additional links under certain conditions. Let's say, we have to create an additonal link “payment”

"self" : {
  "href" : "http://localhost:8080/api/orders/1"
},
...,
"payment" : {
  "href" : "http://localhost:8080/api/orders/1/pay"
},
…
As we can see, the method process is called with the argument EntityModel<Order> model that is the representation to be modified if needed and returned from the message by further processing (serialization). It means, we have to construct the Link object and add it to the model. The addition is trivial, we are using method “add” exposed by the EntityModel class. In order to construct the Link to be added, we can use the following constructor public Link(String href, String rel) where the href is URI, and rel is Relation. In other words, our href should be "http://localhost:8080/api/orders/1/pay", and the rel – "payment". So the question is how to construct the href URI easily. The answer lies in the model object supplied to us an argument by the Spring framework.

The debugger screenshot above shows that the model (our resource Order representation) has been already modified by the framework and it links collection firstly is not empty, and secondly its the first is “self” Link. We are almost at end of our presentation here. All we have to do is to concatenate its with the “/pay”, create the Link instance, add it to the model, and return the modified representation to the framework for the further serialization.  And that's it folks! You can start the spring boot application and follow steps outlined in the README.adoc
$ curl localhost:8080/api/orders/1 { "orderStatus" : "BEING_CREATED", "description" : "grande mocha", "_links" : {
"self" : {
  "href" : "http://localhost:8080/api/orders/1"
},
"order" : {
  "href" : "http://localhost:8080/api/orders/1"
},
"payment" : {
  "href" : "http://localhost:8080/api/orders/1/pay"
},
"cancel" : {
  "href" : "http://localhost:8080/api/orders/1/cancel"
}
}
====
Apply the payment link:
====
$ curl -X POST localhost:8080/api/orders/1/pay { "id" : 1, "orderStatus" : "PAID_FOR", "description" : "grande mocha" }
$ curl localhost:8080/api/orders/1 { "orderStatus" : "PAID_FOR", "description" : "grande mocha", "_links" : {
"self" : {
  "href" : "http://localhost:8080/api/orders/1"
},
"order" : {
  "href" : "http://localhost:8080/api/orders/1"
},
"fulfill" : {
  "href" : "http://localhost:8080/api/orders/1/fulfill"
}
}
====
The `pay` and `cancel` links have disappeared, replaced with a `fulfill` link.
Fulfill the order and see the final state:
====
$ curl -X POST localhost:8080/api/orders/1/fulfill { "id" : 1, "orderStatus" : "FULFILLED", "description" : "grande mocha" }
$ curl localhost:8080/api/orders/1 { "orderStatus" : "FULFILLED", "description" : "grande mocha", "_links" : {
"self" : {
  "href" : "http://localhost:8080/api/orders/1"
},
"order" : {
  "href" : "http://localhost:8080/api/orders/1"
}
}
It is also worth to notice that we reused the test case OrderIntegrationTest.java written by Greg Turnquist and for that we are gratefull to him!.
The authors do hope that you find the proposed approach reasonable and most importantly useful in your own development endavours. So Give us a thumb up like if you like it and let us know your thoughts on the subject of the microservices built with Spring Boot – Spring Data REST and HATEOAS Api in the comment section.

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/maven-plugin/)
* [Spring Data JPA](https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#boot-features-jpa-and-spring-data)
* [Rest Repositories](https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-use-exposing-spring-data-repositories-rest-endpoint)
* [Spring HATEOAS](https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#boot-features-spring-hateoas)

### Guides
The following guides illustrate how to use some features concretely:

* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Accessing JPA Data with REST](https://spring.io/guides/gs/accessing-data-rest/)
* [Accessing Neo4j Data with REST](https://spring.io/guides/gs/accessing-neo4j-data-rest/)
* [Accessing MongoDB Data with REST](https://spring.io/guides/gs/accessing-mongodb-data-rest/)
* [Building a Hypermedia-Driven RESTful Web Service](https://spring.io/guides/gs/rest-hateoas/)

